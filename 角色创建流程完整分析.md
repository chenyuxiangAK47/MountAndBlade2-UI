# Bannerlord 角色创建流程完整分析

## 一、从"沙盒模式"按钮到角色创建的完整流程

### 1. 主菜单按钮点击

**流程：**
```
用户点击"沙盒模式"按钮
  ↓
InitialMenuOptionVM.ExecuteAction()
  ↓
InitialStateOption.DoAction()  // 执行 Action 委托
  ↓
MBGameManager.StartNewGame(new SandBoxGameManager(...))
```

**关键代码位置：**
- `TaleWorlds.MountAndBlade.ViewModelCollection.InitialMenu.InitialMenuOptionVM.ExecuteAction()`
- `TaleWorlds.MountAndBlade.InitialStateOption.DoAction()`
- `TaleWorlds.MountAndBlade.MBGameManager.StartNewGame()`

### 2. 游戏启动流程

**流程：**
```
MBGameManager.StartNewGame()
  ↓
SandBoxGameManager 初始化
  ↓
可能播放开场动画：VideoPlaybackState（如果配置了）
  ↓
进入 CharacterCreationState（角色创建状态）
```

**关键点：**
- 开场动画在 `Module.cs` 中通过 `VideoPlaybackState` 播放
- 动画播放完成后才会进入 `CharacterCreationState`

### 3. CharacterCreationState 初始化

**流程：**
```
CharacterCreationState 构造函数
  ↓
创建 CharacterCreationManager
  ↓
CharacterCreationManager 构造函数：
  - 创建 _stages 列表（阶段列表）
  - 创建 _narrativeMenus 列表（问卷菜单列表）
  - 创建 SelectedOptions 字典（已选择的选项）
  - 创建 CharacterCreationContent（内容管理器）
  ↓
CharacterCreationState.OnActivate()
  ↓
CharacterCreationManager.OnStateActivated()
  ↓
如果 _stageIndex == -1，调用 NextStage()
```

**关键代码：**
```csharp
// CharacterCreationState.cs
public CharacterCreationState()
{
    CharacterCreationManager = new CharacterCreationManager(this);
}

protected override void OnActivate()
{
    base.OnActivate();
    CharacterCreationManager.OnStateActivated();  // 这里会触发 NextStage()
}
```

### 4. Stage 阶段系统

**Stage 顺序（根据 CharacterCreationCampaignBehavior）：**
```
Stage 0: CharacterCreationCultureStage（选择文化）
Stage 1: CharacterCreationFaceGeneratorStage（捏脸）
Stage 2: CharacterCreationNarrativeStage（问卷阶段）
Stage 3: CharacterCreationBannerEditorStage（旗帜编辑）
Stage 4: CharacterCreationClanNamingStage（家族命名）
Stage 5: CharacterCreationReviewStage（回顾）
Stage 6: CharacterCreationOptionsStage（选项）
```

**NextStage() 流程：**
```csharp
public void NextStage()
{
    _stageIndex++;
    if (CurrentStage != null)
    {
        CurrentStage?.OnFinalize();  // 完成当前阶段
        // 通知所有 handler
    }
    
    if (_stageIndex == _stages.Count)
    {
        // 所有阶段完成
        ApplyFinalEffects();
        _state.FinalizeCharacterCreationState();  // 进入 MapState
    }
    else
    {
        ActivateStage(_stages[_stageIndex]);  // 激活下一个阶段
        _state.Refresh();
    }
}
```

### 5. CultureStage（文化选择阶段）

**流程：**
```
CharacterCreationCultureStage 激活
  ↓
UI 显示文化选择界面
  ↓
用户选择文化（例如：Vlandia）
  ↓
CharacterCreationContent.SetSelectedCulture(culture, manager)
  ↓
文化设置完成，等待用户点击"下一步"
  ↓
NextStage() → 进入 FaceGeneratorStage
```

**关键方法：**
- `CharacterCreationContent.SetSelectedCulture(CultureObject culture, CharacterCreationManager manager)`
- `CharacterCreationContent.GetCultures()` - 获取所有可用文化

### 6. NarrativeStage（问卷阶段）

**这是最复杂的阶段，包含多个 NarrativeMenu（问卷菜单）**

**流程：**
```
CharacterCreationNarrativeStage 激活
  ↓
CharacterCreationManager.StartNarrativeStage()
  ↓
查找 InputMenuId == "start" 的 NarrativeMenu
  ↓
设置 CurrentMenu = startMenu
  ↓
ModifyMenuCharacters()  // 更新菜单中的角色显示
  ↓
UI 显示第一个问卷菜单
  ↓
用户选择选项
  ↓
OnNarrativeMenuOptionSelected(option)
  ↓
SelectedOptions[CurrentMenu] = option
  ↓
option.OnSelect(this)  // 执行选项的副作用
  ↓
用户点击"下一步"
  ↓
TrySwitchToNextMenu()
  ↓
查找 InputMenuId == CurrentMenu.StringId 的下一个菜单
  ↓
如果找到：CurrentMenu = nextMenu，返回 true
  ↓
如果没找到：返回 false（问卷结束）
  ↓
NextStage() → 进入下一个 Stage
```

**关键方法：**
- `StartNarrativeStage()` - 初始化问卷阶段，设置 CurrentMenu
- `GetSuitableNarrativeMenuOptions()` - 获取当前菜单的可用选项（过滤条件）
- `OnNarrativeMenuOptionSelected(NarrativeMenuOption option)` - 选择选项
- `TrySwitchToNextMenu()` - 切换到下一个问卷菜单

**NarrativeMenu 结构：**
- `StringId` - 菜单的唯一标识符
- `InputMenuId` - 指向这个菜单的"入口"（用于 TrySwitchToNextMenu 查找）
- `CharacterCreationMenuOptions` - 选项列表
- `Characters` - 菜单中显示的角色

**NarrativeMenuOption 结构：**
- `OnCondition(CharacterCreationManager manager)` - 判断选项是否可用
- `OnSelect(CharacterCreationManager manager)` - 选择时的副作用
- `OnConsequence(CharacterCreationManager manager)` - 切换到下一个菜单时的副作用

### 7. 完成角色创建

**流程：**
```
所有 Stage 完成
  ↓
CharacterCreationManager.ApplyFinalEffects()
  ↓
应用文化、选项效果等
  ↓
CharacterCreationState.FinalizeCharacterCreationState()
  ↓
GameStateManager.CleanAndPushState(new MapState())
  ↓
进入大地图
```

## 二、如何自动完成整个流程

### 1. 跳过开场动画

**方案 A：Patch VideoPlaybackState**
```csharp
[HarmonyPatch(typeof(VideoPlaybackState))]
public static class SkipVideoPlaybackPatch
{
    static void Prefix(VideoPlaybackState __instance)
    {
        if (QuickStartHelper.IsQuickStartMode)
        {
            // 立即结束视频播放
            // 需要找到 VideoPlaybackState 的结束方法
        }
    }
}
```

**方案 B：在 StartNewGame 后立即跳过**
```csharp
// 在 OnApplicationTick 中检测 VideoPlaybackState
if (ActiveState is VideoPlaybackState && QuickStartHelper.IsQuickStartMode)
{
    // 调用结束方法或直接切换到下一个状态
}
```

### 2. 自动选择文化（CultureStage）

**时机：** CharacterCreationCultureStage 激活后

**方法：**
```csharp
// 在 CharacterCreationManager.OnStateActivated() 或 CultureStage 激活时
var content = manager.CharacterCreationContent;
var cultures = content.GetCultures();
var vlandia = cultures.FirstOrDefault(c => c.StringId == "vlandia");
if (vlandia != null)
{
    content.SetSelectedCulture(vlandia, manager);
    // 等待一小段时间让 UI 更新
    // 然后调用 NextStage()
}
```

### 3. 自动跳过捏脸（FaceGeneratorStage）

**方案：** 直接调用 `NextStage()`，不进行任何操作

### 4. 自动完成问卷（NarrativeStage）

**关键：** 必须在 `StartNarrativeStage()` 之后，`CurrentMenu != null` 时才能操作

**流程：**
```
1. 等待 StartNarrativeStage() 被调用（通过 Harmony Patch 检测）
   ↓
2. 设置 QuickStartHelper.InNarrative = true
   ↓
3. 在 OnApplicationTick 中循环执行：
   a. 检查 CurrentMenu != null
   b. 获取 GetSuitableNarrativeMenuOptions()
   c. 选择第一个选项（或优先选择 Vlandia 相关的）
   d. 调用 OnNarrativeMenuOptionSelected(option)
   e. 调用 TrySwitchToNextMenu()
   f. 如果 TrySwitchToNextMenu() 返回 false，说明问卷结束
   g. 等待 NextStage() 被调用（进入下一个 Stage）
```

**代码示例：**
```csharp
// 在 StartNarrativeStage Postfix 中
QuickStartHelper.InNarrative = true;

// 在 OnApplicationTick 中
if (QuickStartHelper.InNarrative && manager.CurrentMenu != null)
{
    var options = manager.GetSuitableNarrativeMenuOptions();
    var firstOption = options.FirstOrDefault();
    if (firstOption != null)
    {
        manager.OnNarrativeMenuOptionSelected(firstOption);
        manager.TrySwitchToNextMenu();
    }
}
```

### 5. 自动跳过其他阶段

**BannerEditorStage、ClanNamingStage、ReviewStage、OptionsStage：**
- 这些阶段通常有默认值或可以快速通过
- 方案：检测到这些 Stage 激活时，直接调用 `NextStage()`

### 6. 完整自动流程时序图

```
用户点击"快速开始"
  ↓
设置 QuickStartHelper.IsQuickStartMode = true
  ↓
执行沙盒模式的 Action（启动新游戏）
  ↓
[可选] 跳过 VideoPlaybackState（开场动画）
  ↓
进入 CharacterCreationState
  ↓
Stage 0: CultureStage
  → 自动选择 Vlandia
  → 等待 0.2s
  → NextStage()
  ↓
Stage 1: FaceGeneratorStage
  → 直接 NextStage()（跳过捏脸）
  ↓
Stage 2: NarrativeStage
  → StartNarrativeStage() → CurrentMenu = startMenu
  → 循环：
     - 选择第一个选项
     - TrySwitchToNextMenu()
     - 如果返回 false，问卷结束
  → NextStage()
  ↓
Stage 3-6: 其他阶段
  → 每个阶段直接 NextStage()
  ↓
所有阶段完成
  → ApplyFinalEffects()
  → FinalizeCharacterCreationState()
  → 进入 MapState
  ↓
发放启动资金（100,000 第纳尔）
```

## 三、关键 API 总结

### CharacterCreationManager 关键方法

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `NextStage()` | 进入下一个阶段 | 无 | void |
| `StartNarrativeStage()` | 开始问卷阶段，设置 CurrentMenu | 无 | void |
| `GetSuitableNarrativeMenuOptions()` | 获取当前菜单的可用选项 | 无 | `IEnumerable<NarrativeMenuOption>` |
| `OnNarrativeMenuOptionSelected(NarrativeMenuOption)` | 选择选项 | option | void |
| `TrySwitchToNextMenu()` | 切换到下一个问卷菜单 | 无 | bool（成功返回 true） |
| `CurrentMenu` | 当前问卷菜单 | - | `NarrativeMenu` |

### CharacterCreationContent 关键方法

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `SetSelectedCulture(CultureObject, CharacterCreationManager)` | 设置选中的文化 | culture, manager | void |
| `GetCultures()` | 获取所有可用文化 | 无 | `IEnumerable<CultureObject>` |
| `SelectedCulture` | 当前选中的文化 | - | `CultureObject` |

### CharacterCreationState 关键方法

| 方法 | 说明 | 参数 | 返回值 |
|------|------|------|--------|
| `FinalizeCharacterCreationState()` | 完成角色创建，进入 MapState | 无 | void |
| `CharacterCreationManager` | 角色创建管理器 | - | `CharacterCreationManager` |

## 四、实现自动完成的策略

### 策略 1：分阶段 Hook（推荐）

**优点：** 清晰、稳定、易于调试

**实现：**
1. Hook `CharacterCreationManager.OnStateActivated()` - 检测阶段激活
2. Hook `CharacterCreationManager.StartNarrativeStage()` - 检测问卷开始
3. 在 `OnApplicationTick` 中根据当前阶段执行相应逻辑

### 策略 2：统一 Tick 检测

**优点：** 简单

**实现：**
- 在 `OnApplicationTick` 中检测当前 Stage 和 CurrentMenu
- 根据状态执行相应操作

### 策略 3：直接 Patch 关键方法

**优点：** 最精确

**实现：**
- Patch `NextStage()` - 在进入每个阶段时自动完成
- Patch `StartNarrativeStage()` - 在问卷开始时自动选择
- Patch `TrySwitchToNextMenu()` - 在切换菜单时自动选择下一个选项

## 五、跳过开场动画的实现

### VideoPlaybackState 结构

根据反编译代码：
```csharp
public class VideoPlaybackState : GameState
{
    private Action _onVideoFinised;  // 视频结束时的回调
    
    public void OnVideoFinished()
    {
        MBMusicManager.Current.UnpauseMusicManagerSystem();
        _onVideoFinised?.Invoke();  // 调用回调，通常会进入下一个状态
    }
}
```

### 方案 A：Patch VideoPlaybackState.OnActivate（推荐）

```csharp
[HarmonyPatch(typeof(VideoPlaybackState))]
public static class SkipVideoPlaybackPatch
{
    static void Postfix(VideoPlaybackState __instance)
    {
        if (QuickStartHelper.IsQuickStartMode)
        {
            // 立即调用 OnVideoFinished() 跳过视频
            __instance.OnVideoFinished();
        }
    }
}
```

### 方案 B：在 OnApplicationTick 中检测并跳过

```csharp
// 在 OnApplicationTick 中
if (QuickStartHelper.IsQuickStartMode)
{
    var state = Game.Current?.GameStateManager?.ActiveState;
    if (state != null && state.GetType().Name == "VideoPlaybackState")
    {
        // 调用 OnVideoFinished() 方法
        var finishMethod = state.GetType().GetMethod("OnVideoFinished", 
            BindingFlags.Public | BindingFlags.Instance);
        if (finishMethod != null)
        {
            finishMethod.Invoke(state, null);
            QuickStartHelper.VideoSkipped = true;  // 标记已跳过
        }
    }
}
```

### 方案 C：Patch VideoPlaybackState 的 OnTick（如果存在）

如果 VideoPlaybackState 有 OnTick 方法，可以在第一帧就跳过：
```csharp
[HarmonyPatch(typeof(VideoPlaybackState))]
public static class SkipVideoPlaybackTickPatch
{
    static MethodBase TargetMethod()
    {
        var t = typeof(VideoPlaybackState);
        return AccessTools.Method(t, "OnTick", new[] { typeof(float) })
            ?? AccessTools.Method(t, "Tick", new[] { typeof(float) });
    }
    
    static void Prefix(VideoPlaybackState __instance)
    {
        if (QuickStartHelper.IsQuickStartMode && !QuickStartHelper.VideoSkipped)
        {
            __instance.OnVideoFinished();
            QuickStartHelper.VideoSkipped = true;
        }
    }
}
```

## 六、注意事项

### 1. 时机问题
- **不要**在 `CurrentMenu == null` 时调用 `TrySwitchToNextMenu()`
- **必须**在 `StartNarrativeStage()` 之后才开始自动选择
- **必须**在每个操作之间添加延迟（0.1-0.2s），避免状态机抖动

### 2. 选项选择策略
- 文化阶段：优先选择 Vlandia
- 问卷阶段：选择第一个可用选项（或根据条件选择）
- 确保选项通过 `OnCondition()` 检查

### 3. 错误处理
- 如果 `TrySwitchToNextMenu()` 返回 false，说明问卷结束，应该等待 `NextStage()`
- 如果 `GetSuitableNarrativeMenuOptions()` 返回空，说明当前菜单没有可用选项，需要等待

### 4. 状态管理
- 使用 `QuickStartHelper.InNarrative` 标志确保只在问卷阶段自动选择
- 使用 `QuickStartHelper.SeenCharacterCreation` 防止误判完成
- 使用 `QuickStartHelper.CharCreationDone` 防止重复操作

## 七、推荐实现方案

### 核心逻辑（伪代码）

```csharp
// 1. Hook StartNarrativeStage
[HarmonyPatch(typeof(CharacterCreationManager), "StartNarrativeStage")]
public static class StartNarrativeStagePatch
{
    static void Postfix(CharacterCreationManager __instance)
    {
        if (QuickStartHelper.IsQuickStartMode)
        {
            QuickStartHelper.InNarrative = true;
        }
    }
}

// 2. 在 OnApplicationTick 中自动完成
void OnApplicationTick(float dt)
{
    if (!QuickStartHelper.IsQuickStartMode) return;
    
    var manager = GetCharacterCreationManager();
    if (manager == null) return;
    
    // 阶段 0: 选择文化
    if (manager.CurrentStage is CharacterCreationCultureStage)
    {
        if (manager.CharacterCreationContent.SelectedCulture == null)
        {
            SetCultureToVlandia(manager);
            Wait(0.2f);
            manager.NextStage();
        }
    }
    
    // 阶段 1: 跳过捏脸
    if (manager.CurrentStage is CharacterCreationFaceGeneratorStage)
    {
        Wait(0.1f);
        manager.NextStage();
    }
    
    // 阶段 2: 自动完成问卷
    if (QuickStartHelper.InNarrative && manager.CurrentMenu != null)
    {
        var options = manager.GetSuitableNarrativeMenuOptions();
        if (options.Any())
        {
            var firstOption = options.First();
            manager.OnNarrativeMenuOptionSelected(firstOption);
            Wait(0.15f);
            if (!manager.TrySwitchToNextMenu())
            {
                // 问卷结束，等待 NextStage
                QuickStartHelper.InNarrative = false;
            }
        }
    }
    
    // 阶段 3-6: 自动跳过
    if (manager.CurrentStage is CharacterCreationBannerEditorStage ||
        manager.CurrentStage is CharacterCreationClanNamingStage ||
        manager.CurrentStage is CharacterCreationReviewStage ||
        manager.CurrentStage is CharacterCreationOptionsStage)
    {
        Wait(0.1f);
        manager.NextStage();
    }
}
```

## 八、需要进一步确认的信息

1. **VideoPlaybackState 的结束方法**：需要确认如何跳过开场动画
2. **NarrativeMenu 的完整结构**：需要确认所有菜单的 StringId 和 InputMenuId
3. **选项的 OnCondition 逻辑**：需要确认哪些选项在什么条件下可用
4. **Stage 的 OnFinalize 逻辑**：需要确认跳过某些阶段是否会有副作用

## 九、检测当前 Stage 的方法

### 方法 1：通过 CurrentStage 属性

```csharp
var manager = GetCharacterCreationManager();
if (manager != null)
{
    var currentStage = manager.CurrentStage;
    if (currentStage != null)
    {
        var stageType = currentStage.GetType();
        var stageTypeName = stageType.Name;
        
        if (stageTypeName == "CharacterCreationCultureStage")
        {
            // 文化选择阶段
        }
        else if (stageTypeName == "CharacterCreationNarrativeStage")
        {
            // 问卷阶段
        }
        // ...
    }
}
```

### 方法 2：通过 Stage 索引

```csharp
var stageIndex = manager.GetIndexOfCurrentStage();
// Stage 顺序：
// 0: CultureStage
// 1: FaceGeneratorStage
// 2: NarrativeStage
// 3: BannerEditorStage
// 4: ClanNamingStage
// 5: ReviewStage
// 6: OptionsStage
```

### 方法 3：通过反射获取 Stage 类型

```csharp
var currentStage = manager.CurrentStage;
if (currentStage != null)
{
    var stageType = currentStage.GetType();
    var baseType = typeof(CharacterCreationStageBase);
    
    // 检查是否是特定类型的 Stage
    if (stageType.IsSubclassOf(baseType))
    {
        // 可以通过类型名判断
        var name = stageType.Name;
    }
}
```

## 十、完整实现伪代码

```csharp
// 1. 跳过开场动画
[HarmonyPatch(typeof(VideoPlaybackState))]
public static class SkipVideoPlaybackPatch
{
    static void Postfix(VideoPlaybackState __instance)
    {
        if (QuickStartHelper.IsQuickStartMode)
        {
            __instance.OnVideoFinished();
        }
    }
}

// 2. 检测问卷开始
[HarmonyPatch(typeof(CharacterCreationManager), "StartNarrativeStage")]
public static class StartNarrativeStagePatch
{
    static void Postfix(CharacterCreationManager __instance)
    {
        if (QuickStartHelper.IsQuickStartMode)
        {
            QuickStartHelper.InNarrative = true;
        }
    }
}

// 3. 主逻辑（在 OnApplicationTick 中）
void AutoCompleteCharacterCreation(float dt)
{
    if (!QuickStartHelper.IsQuickStartMode || QuickStartHelper.CharCreationDone)
        return;
    
    var manager = GetCharacterCreationManager();
    if (manager == null) return;
    
    var currentStage = manager.CurrentStage;
    if (currentStage == null) return;
    
    var stageTypeName = currentStage.GetType().Name;
    
    // Stage 0: 选择文化
    if (stageTypeName == "CharacterCreationCultureStage")
    {
        if (manager.CharacterCreationContent.SelectedCulture == null)
        {
            SetCultureToVlandia(manager);
            Wait(0.2f);
            manager.NextStage();
        }
        return;
    }
    
    // Stage 1: 跳过捏脸
    if (stageTypeName == "CharacterCreationFaceGeneratorStage")
    {
        Wait(0.1f);
        manager.NextStage();
        return;
    }
    
    // Stage 2: 自动完成问卷
    if (stageTypeName == "CharacterCreationNarrativeStage")
    {
        if (QuickStartHelper.InNarrative && manager.CurrentMenu != null)
        {
            var options = manager.GetSuitableNarrativeMenuOptions().ToList();
            if (options.Count > 0)
            {
                var firstOption = options[0];
                manager.OnNarrativeMenuOptionSelected(firstOption);
                Wait(0.15f);
                
                if (!manager.TrySwitchToNextMenu())
                {
                    // 问卷结束
                    QuickStartHelper.InNarrative = false;
                    Wait(0.2f);
                    manager.NextStage();
                }
            }
        }
        return;
    }
    
    // Stage 3-6: 自动跳过
    if (stageTypeName == "CharacterCreationBannerEditorStage" ||
        stageTypeName == "CharacterCreationClanNamingStage" ||
        stageTypeName == "CharacterCreationReviewStage" ||
        stageTypeName == "CharacterCreationOptionsStage")
    {
        Wait(0.1f);
        manager.NextStage();
        return;
    }
}
```

## 十一、测试建议

1. **逐步测试**：先测试文化选择，再测试问卷，最后测试完整流程
2. **日志记录**：记录每个阶段的状态、CurrentMenu、可用选项等
3. **错误处理**：确保每个操作都有异常捕获，避免崩溃
4. **延迟调整**：根据实际情况调整操作之间的延迟时间
5. **状态验证**：在每个操作前后验证状态，确保操作成功

## 十二、常见问题和解决方案

### 问题 1：CurrentMenu 一直为 null

**原因：** `StartNarrativeStage()` 还没被调用

**解决：** 等待 `StartNarrativeStage()` 被调用（通过 Harmony Patch 检测）

### 问题 2：TrySwitchToNextMenu() 一直返回 false

**原因：** 可能已经到达最后一个菜单，或者选项没有正确选择

**解决：** 检查 `SelectedOptions[CurrentMenu]` 是否已设置，如果已设置且返回 false，说明问卷结束

### 问题 3：NextStage() 后没有进入下一个阶段

**原因：** 当前阶段可能还有未完成的操作

**解决：** 确保在调用 `NextStage()` 前，当前阶段的所有操作都已完成

### 问题 4：开场动画无法跳过

**原因：** `OnVideoFinished()` 可能需要在特定时机调用

**解决：** 尝试在 `OnActivate` 或第一帧 `OnTick` 时调用

