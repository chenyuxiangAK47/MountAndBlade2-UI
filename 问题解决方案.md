# QuickStart Mod 开发问题与解决方案

本文档记录了在开发 QuickStart Mod 过程中遇到的所有问题和解决方案。

## 问题 1: TextObject 构造函数创建失败

### 问题描述

尝试使用反射创建 `TextObject` 实例时失败：
```
[QuickStart] 创建 TextObject 失败: Constructor on type 'TaleWorlds.Localization.TextObject' not found.
```

### 原因

`TextObject` 没有接受 `string` 的公共构造函数，或者构造函数签名不是我们猜测的那样。

### 解决方案

**使用强类型引用 `TaleWorlds.Localization.dll`**，而不是使用反射：

1. 在 `.csproj` 中添加引用：
```xml
<Reference Include="TaleWorlds.Localization">
  <HintPath>$(BANNERLORD_INSTALL_DIR)\bin\Win64_Shipping_Client\TaleWorlds.Localization.dll</HintPath>
  <Private>False</Private>
</Reference>
```

2. 使用强类型创建：
```csharp
using TaleWorlds.Localization;

var name = new TextObject("{=qs_quickstart}快速开始");
var hint = new TextObject("{=qs_quickstart_hint}直接进入沙盒并给予初始资源");
```

### 关键点

- **不要使用反射创建 `TextObject`**，直接引用 DLL 使用强类型
- 使用 `"{=id}文本"` 格式支持本地化

---

## 问题 2: 菜单项插入成功但不显示

### 问题描述

日志显示菜单项插入成功（`MenuOptions.Count` 从 0 变为 1），但按钮在游戏中不显示。

### 原因分析

1. **时机问题**: `RefreshValues` 被调用时，`MenuOptions.Count == 0`，说明原版菜单项还没有被填充
2. **被覆盖**: 插入后，后续逻辑可能重新填充 `MenuOptions`，覆盖了我们的插入
3. **只 Patch 了一个方法**: 只 Patch 了 `RefreshValues`，可能错过了真正填充菜单的时机

### 解决方案

**使用 `TargetMethods()` 自动 Patch 多个方法，只在 `MenuOptions.Count > 0` 时插入**：

1. 使用 Harmony 的 `TargetMethods()` 特性自动 Patch 多个方法：
```csharp
[HarmonyPatch(typeof(InitialMenuVM))]
public static class QuickStartMenuInjectPatch
{
    public static IEnumerable<MethodBase> TargetMethods()
    {
        // 1) 构造函数
        var ctor = AccessTools.Constructor(typeof(InitialMenuVM));
        if (ctor != null) yield return ctor;

        // 2) RefreshValues
        var rv = AccessTools.Method(typeof(InitialMenuVM), "RefreshValues");
        if (rv != null) yield return rv;

        // 3) 自动扫描包含 Refresh/Menu/Option 的方法
        var ms = AccessTools.GetDeclaredMethods(typeof(InitialMenuVM));
        foreach (var m in ms)
        {
            if (m.IsSpecialName) continue;
            if (m.ReturnType != typeof(void)) continue;
            if (m.GetParameters().Length != 0) continue;

            var n = m.Name;
            if (n.Contains("Refresh") && (n.Contains("Menu") || n.Contains("Option")))
                yield return m;
        }
    }

    public static void Postfix(InitialMenuVM __instance, MethodBase __originalMethod)
    {
        EnsureQuickStart(__instance);
    }
}
```

2. 只在 `MenuOptions.Count > 0` 时插入：
```csharp
private static void EnsureQuickStart(InitialMenuVM vm)
{
    if (vm?.MenuOptions == null) return;
    
    // ⭐关键：原版菜单还没填充时（Count=0），先别插
    if (vm.MenuOptions.Count == 0) return;
    
    // 检查是否已存在
    foreach (var opt in vm.MenuOptions)
    {
        if (opt?.NameText?.ToString().Contains("快速开始") == true)
            return;
    }
    
    // 创建并插入菜单项...
}
```

3. 使用 `PatchAll` 让 Harmony 自动调用 `TargetMethods()`：
```csharp
_harmony.PatchAll(typeof(QuickStartMenuInjectPatch).Assembly);
```

### 关键点

- **不要在 `MenuOptions.Count == 0` 时插入**，会被后续逻辑覆盖
- **Patch 多个方法**，确保能捕获到菜单填充完成的时机
- **使用 `OnPropertyChanged("MenuOptions")` 强制 UI 刷新**

---

## 问题 3: ViewModelMixin 导致 UIExtenderEx 启用失败

### 问题描述

使用 `ViewModelMixin` 时，`UIExtenderEx.Enable()` 抛出 `NullReferenceException`：
```
System.NullReferenceException: Object reference not set to an instance of an object.
at HarmonyLib.AccessTools.IsDeclaredMember[T](T member)
at Bannerlord.UIExtenderEx.Patches.ViewModelWithMixinPatch.Patch(...)
```

### 原因

`ViewModelMixin` 在解析目标方法时失败，导致 `member` 为 null。

### 解决方案

**完全绕过 `ViewModelMixin`，直接使用 Harmony 注入菜单项**：

- 不使用 `ViewModelMixin` 注入方法
- 不使用 `PrefabExtension` 插入 UI 元素
- 直接使用 Harmony Patch 往 `MenuOptions` 列表添加菜单项 VM

### 关键点

- **最稳的方案是完全不使用 UIExtenderEx 的 ViewModelMixin**
- 直接操作 `InitialMenuVM.MenuOptions` 列表更稳定

---

## 问题 4: InitialStateOption 构造函数参数不匹配

### 问题描述

尝试创建 `InitialStateOption` 时，构造函数参数不匹配。

### 解决方案

根据日志中的构造函数签名，使用正确的参数：

```csharp
var stateOption = new InitialStateOption(
    "quick_start",                    // string id
    name,                              // TextObject name
    orderIndex: -100,                  // int orderIndex (使用负数确保在顶部)
    action: action,                    // Action action
    isDisabledAndReason: () => (false, new TextObject("")), // Func<(bool, TextObject)>
    enabledHint: hint,                 // TextObject enabledHint
    isHidden: () => false              // Func<bool> isHidden
);
```

### 关键点

- 使用 `orderIndex: -100` 确保按钮显示在顶部
- `isDisabledAndReason` 返回 `(bool, TextObject)` 元组

---

## 最终解决方案总结

### 核心思路

1. **使用强类型，不使用反射**
   - 引用 `TaleWorlds.Localization.dll`
   - 直接使用 `new TextObject()` 和 `new InitialStateOption()`

2. **使用 Harmony 的 `TargetMethods()` 自动 Patch 多个方法**
   - Patch 构造函数、RefreshValues、以及其他相关方法
   - 确保能捕获到菜单填充完成的时机

3. **只在 `MenuOptions.Count > 0` 时插入**
   - 避免在空列表时插入后被覆盖
   - 确保插入的时机正确

4. **强制 UI 刷新**
   - 使用 `OnPropertyChanged("MenuOptions")` 通知 UI 更新
   - 如果找不到该方法，使用 `RefreshValues()` 兜底

### 关键代码结构

```csharp
[HarmonyPatch(typeof(InitialMenuVM))]
public static class QuickStartMenuInjectPatch
{
    // 自动 Patch 多个方法
    public static IEnumerable<MethodBase> TargetMethods() { ... }
    
    // Postfix 统一处理
    public static void Postfix(InitialMenuVM __instance, MethodBase __originalMethod)
    {
        EnsureQuickStart(__instance);
    }
    
    // 只在 Count > 0 时插入
    private static void EnsureQuickStart(InitialMenuVM vm)
    {
        if (vm.MenuOptions.Count == 0) return; // ⭐关键
        // ... 创建并插入菜单项
    }
}
```

---

## 参考资源

- [Harmony 文档](https://github.com/pardeike/Harmony)
- [UIExtenderEx 文档](https://github.com/Bannerlord-Modding/Documentation)
- [Mount & Blade II: Bannerlord Modding Wiki](https://modding.wiki/en/mountandblade/bannerlord)

---

## 开发时间线

1. **初始尝试**: 使用 UIExtenderEx 的 PrefabExtension + ViewModelMixin
2. **问题 1**: ViewModelMixin 导致 UIExtenderEx 启用失败
3. **问题 2**: 尝试使用反射创建 TextObject 失败
4. **问题 3**: 菜单项插入成功但不显示
5. **最终解决**: 使用强类型 + TargetMethods() + 条件插入

---

**开发完成日期**: 2025-01-XX










